/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;

import java.io.*;
import recovery.*;

public class Fun
{
  boolean MenosShort = false;
  int contParseError = 0;

  public static void main(String args []) throws ParseException
  {
    String filename = "";
    Fun parser;
    boolean ms = false;
    String intro_msg = "Trabalho de Introdução a Compiladores. ";
    String modo_padrao_msg = "Fun está operando em modo padrão.";
    String modo_arquivo_msg = "Fun está operando em modo leitura de arquivo.";
    String input_msg = "Insira o valor que deseja validar (Para sair Ctrl+C)";
    String usage_msg = "Uso : -short <path/do/arquivo> \n Pode ser utilizado sem parametros para modo de input de valores";
    String file_not_found_msg = "Arquivo não foi localizado, favor verificar se está correto";
    String reading_file_msg = "Lendo o arquivo : ";
    String lexical_error_msg = " erros lexicos foram encontrados";
    boolean debug = false;
    int i = 0;

    System.out.println(intro_msg);

    if (args.length == 0)
    {
      System.out.println(modo_padrao_msg);
      parser = new Fun(System.in);
      parser.MenosShort = false;
      System.out.println(input_msg);
      try
      {
        parser.program();
        lexError(lexical_error_msg, parser.token_source.foundLexError());
      }
      catch (Exception ex)
      {
        System.err.println(ex);
        System.exit(0);
      }
    }
    else
    {
        // Imprimi mensagem de auxilio (Usage Message)
        if ( args.length == 1)
        {
            System.out.println(usage_msg);
            System.exit(0);
        }
        // TODO : Assume que apenas 1 arquivo será passado por vez,
        //        melhorar os argumentos para tratar multiplos arquivos.
        else
        {

            for (i = 0; i < args.length - 1; ++i)
            {
                if (args[i].toLowerCase().equals("-short"))
                {
                    ms = true;
                }
                else if( args[i].toLowerCase().equals("-debug_as"))
                {
                    debug = true;
                }
                else
                {
                    System.out.println(usage_msg);
                    System.exit(0);
                }
            }
            filename = args[i];
            System.out.println(reading_file_msg + filename);
            try {
                parser = new Fun(new java.io.FileInputStream(filename));
                parser.MenosShort = ms;
                if (!debug)
                {
                    parser.disable_tracing(); // desabilita verbose do AS
                }

                // Infelizmente este foi o unico jeito de garantir que parser vai existir dentro do catch que
                // incrementa parser.contParseError.
                try
                {

                    parser.program();

                }
                catch (ParseEOFException ex)
                {
                    System.err.println(ex.getMessage());
                    parser.contParseError = 1;
                }
                finally
                {
                    lexError(lexical_error_msg, parser.token_source.foundLexError());
                    System.out.println(parser.contParseError + " Erro sintatico encontrado");
                }
            }
            catch (java.io.FileNotFoundException e)
            {
                System.out.println(file_not_found_msg);
                System.exit(0);
            }
        }
    }
  }

  static public String im(int x)
  {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try
    {
      s = s.substring(1,k);
    }
    catch (StringIndexOutOfBoundsException ex)
    {
        System.out.println(ex);
        System.exit(0);
    }

    return s;
  }

  static public void lexError(String msg, int errorCount)
  {
      String program_success_msg = "O programa foi corretamente analisado";

      if (errorCount != 0)
      {
        System.out.println(errorCount + msg);
      }
      else
      {
        System.out.println(program_success_msg);
      }
  }

boolean eof;

void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException
{
  	Token tok;

	if (g==null)
	    throw e;
	tok = getToken(1);

	while (!eof) {
	  if (g.contains(tok.kind)) {
	    break;
	  }
	  getNextToken();
	  tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) )
	  	eof = true;
	  }
	System.out.println(e.getMessage());
	contParseError++;
	if ( eof )
	 throw new ParseEOFException("EOF found prematurely.");
}

}
PARSER_END(Fun)

TOKEN_MGR_DECLS:
{
    int countLexError = 0;

    public int foundLexError()
    {
        return countLexError;
    }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SKIP:
{
  "/*" : MULTICOMMENTMODE
}

SKIP:
{
  "//" : SINGLECOMMENTMODE
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < ASSIGN : "=" >
| < DIVIDE : "/" >
| < NOT : "!" | "not" | "NOT" >
| < AND : "&&" | "and" | "AND" >
| < OR : "||" | "or" | "OR" >
| < XOR : "^" | "xor" | "XOR" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE: "<=">
| < GE: ">=">
| < NEQ : "!=" | "><" >
| < REM : "%" >
}

TOKEN :
{
  < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
| < STRING : "string" >
| < INTEGER : "int" >
| < BREAK : "break" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < SUPER : "super" >
| < IF : "if" >
| < ELSE : "else" >
| < FOR : "for" >
| < NEW : "new" >
| < FLUSH : "flush" >
| < CONSTRUCTOR : "constructor" >
| < CLASS : ( "class" ) >
| < EXTENDS : ( "extends" ) >
| < VOID : ("void") >
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN :
{
      < float_constant : ( ("-")? ( (["0"-"9"])+ "." (["0"-"9"])+) ) >
    | < integer_constant : ( ("-")? (["0"-"9"])+ ) >
    | < boolean_constant : "true" | "false" | "True" | "False" >
    | < char_constant : "\'" ( ["A"-"Z"] | ["a"-"z"]
                        |  ["0"-"9"] | <VALIDSYMBOLS>
                        | ("\\""n") | ("\\""t") | ("\\""r") | ("\\""f") | ("\"") )
                          "\'">
    | < string_constant : "\"" ( ["A"-"Z"] | ["a"-"z"]
                        | ["0"-"9"] | <VALIDSYMBOLS>
                        | ("\\""t") | ("\\""f") | ("\'")
                        )+ "\"" >
    | < null_constant : "null" >
}

TOKEN :
{
  < CONSTANT : (< DIGIT >)+ >
| < IDENT: ( <LETTER> (<LETTER> | <DIGIT> )* )>
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER: ["A"-"Z", "a"-"z"] >
| < #VALIDSYMBOLS : ["a"-"z", "A"-"Z", "0"-"9", "(", ")",
                     "[", "]", "{", "}", ";", ",", ".", "=",
                     ">", "<", "!", "+", "-", "*", "/", "%", " ", "$", "^"] >
}

// Item 2
<MULTICOMMENTMODE> SKIP:
{
  "*/" : DEFAULT
  | <~[]>
}

<SINGLECOMMENTMODE> SKIP:
{
  <["\n","\r"]> : DEFAULT
  | <~[]>  

}

// Item 3
SPECIAL_TOKEN :
{
     <INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "\'", "(",
                         ")", "[", "]", "{", "}", ";", ",", ".", "=",
                         ">", "<", "!", "+", "-", "*", "/", "%", " ", "\t",
                         "\n", "\r", "\f"] )+ >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String invalida encontrada: " + image);
        countLexError++;
     }
|    <INVALID_CONST: ("\"" (~ ["\n", "\r", "\""])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String constante tem " + image + " seguido de \\n: ");
        countLexError++;
     }
|    <INVALID_CHAR: ("\'" (~ ["\n", "\r", "\'"])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - Char constante tem " + image + " seguido de \\n");
        countLexError++;
     }
|    <INVALID_FLOAT: ("-")? ( "." <DIGIT> | <DIGIT> ".") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não é um valor Float valido : " + image);
        countLexError++;
     }
|    <INVALID_LINE_BREAK: ("\"" ((<LETTER> | <DIGIT> )* (("\\""n") | ("\\""r"))  (<LETTER> | <DIGIT> )*) "\"") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir quebra de linha no meio de string. ");
        countLexError++;
     }
|    <INVALID_EMPTY_STRING: ("\""){2} >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir string vazia.");
        countLexError++;
     }
|    <INVALID_EMPTY_CHAR: ("\'"){2} >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir char vazio.");
        countLexError++;
     }
|    <INVALID_SYMBOL_STRING: ("\"" (<INVALID_LEXICAL> | <LETTER> | <DIGIT> )*  "\"") >
     {
              System.err.println("Line " + input_stream.getEndLine() + " Character invalido dentro da string " + image);
              countLexError++;
     }
|    <INVALID_SYMBOL_CHAR: ("\'" <INVALID_LEXICAL> "\'") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Character invalido " + image);
        countLexError++;
     }
}

void classlist(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f = First.classlist.union(g);
}
{
    classdecl(f) [ classlist(g) ]
}

void classdecl(RecoverySet g) throws ParseEOFException :
{
}
{
    try
    {
        <CLASS> <IDENT> [ <EXTENDS> <IDENT> ] classbody(g)
    } catch (ParseException e )
    {
        consumeUntil(g, e, "classdecl");
    }
}

void classbody(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f1 = new RecoverySet(RBRACE),
    f2 = new RecoverySet(SEMICOLON),
    f3 = First.methoddecl.union(f1),
    f4 = First.constructdecl.union(f3),
    f5 = First.vardecl.union(f4);
}
{
    try
    {
        <LBRACE>
            [classlist(f5)]
            (LOOKAHEAD(3) vardecl(f2) <SEMICOLON>)*
            (constructdecl(f4) | methoddecl(f3))*
        <RBRACE>
    } catch (ParseException e)
    {
        consumeUntil(g, e, "classbody");
    }
}

void vardecl(RecoverySet g) throws ParseEOFException :
{}
{
    try
    {
        (<INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> )
        <IDENT> ( <LBRACKET> <RBRACKET> ) *
        (<COMMA> <IDENT> ( <RBRACKET> <LBRACKET>)* )*
        [<ASSIGN> expression(g)]
	} catch (ParseException e)
	{
	    consumeUntil(g, e, "vardecl");
	}
}

void constructdecl(RecoverySet g) throws ParseEOFException :
{}
{
    <CONSTRUCTOR> methodbody(g)
}

void methoddecl(RecoverySet g) throws ParseEOFException :
{}
{
    ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> ) (<RBRACKET> <LBRACKET>)*
    <IDENT> methodbody(g)
}

void methodbody(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f = new RecoverySet(RPAREN);
}
{
    try {
        <LPAREN> paramlist(f) <RPAREN> statement(g)
    } catch (ParseException e)
    {
        consumeUntil(g, e, "methodbody");
    }
}

void paramlist(RecoverySet g) throws ParseEOFException :
{}
{
try
{
    [
        ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> ) <IDENT>
		[<ASSIGN> expression(g)]
		(<RBRACKET> <LBRACKET>)*
        ( <COMMA> ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> )
        <IDENT> [<ASSIGN> expression(g)] (<RBRACKET> <LBRACKET>)* )*
    ]
   } catch (ParseException e)
       {
         consumeUntil(g, e, "paramlist");
       }
}

void statement(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(SEMICOLON);
  RecoverySet f2 = new RecoverySet(RBRACE);
}
{
  try {
	LOOKAHEAD(2)
	vardecl(f1) < SEMICOLON >
|   atribstat(f1) < SEMICOLON >
|	printstat(f1) < SEMICOLON >
|   readstat(f1) < SEMICOLON >
|   returnstat(f1) < SEMICOLON >
|   superstat(f1) < SEMICOLON >
|   ifstat(g)
|   forstat(g)
|   < LBRACE > statlist(f2) < RBRACE >
|   < BREAK > < SEMICOLON >
|   < SEMICOLON >
  }
  catch (ParseException e)
  {
    consumeUntil(g, e, "statement");
  }
}


void atribstat(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f1 = new RecoverySet(ASSIGN);
}
{
try {
    lvalue(f1) <ASSIGN> ( alocexpression(g) | expression(g) )
}
  catch (ParseException e)
  {
      consumeUntil(g, e, "atribstat");
    }

}

void printstat(RecoverySet g) throws ParseEOFException :
{}
{
    try {
      	< PRINT > expression(g)
     }
      catch (ParseException e)
      {
    	consumeUntil(g, e, "printstat");
      }
}

void readstat(RecoverySet g) throws ParseEOFException :
{}
{
    try {
        < READ > lvalue(g)
    }
    catch (ParseException e)
    {
        consumeUntil(g, e, "readstat");
    }
}

void returnstat(RecoverySet g) throws ParseEOFException :
{}
{
    try {
        < RETURN > [expression(g)]
      }
    catch(ParseException e)
      {
        consumeUntil(g, e, "returnstat");
      }
}

void superstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(RPAREN);
}
{
  try {
  	< SUPER > < LPAREN > arglist(f) < RPAREN >
  }
  catch (ParseException e)
  {
    consumeUntil(g, e, "superstat");
  }
}

void ifstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(RPAREN),
  f2 = new RecoverySet(ELSE).union(g);
}
{
  try {
  < IF > < LPAREN > expression(f1) < RPAREN > statement(f2)
  [LOOKAHEAD(1) < ELSE > statement(g)]
  }
  catch (ParseException e)
  {
    consumeUntil(g, e, "ifstat");
  }
}

void forstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(SEMICOLON),
  f2 = new RecoverySet(RPAREN);
}
{
  try {
  < FOR > < LPAREN > [atribstat(f1)] < SEMICOLON >
  					 [expression(f1)] < SEMICOLON >
  					 [atribstat(f2)] < RPAREN >
  					 statement(g)
  }
  catch (ParseException e)
  {
    consumeUntil(g, e, "forstat");
  }
}

void statlist (RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = First.statlist.union(g);
}
{
  statement(f) [statlist(g)]
}


void lvalue(RecoverySet g) throws ParseEOFException :
{}
{
 try {
    <IDENT> (
                <LBRACKET> expression(null) <RBRACKET> |
                <DOT> <IDENT> [<LPAREN> arglist(null) <RPAREN>]
            )*
    }
  catch (ParseException e)
  {
        consumeUntil(g, e, "lvalue");
      }
}

void alocexpression(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(RPAREN);
  RecoverySet f2 = new RecoverySet(RBRACKET);
}
{
  < NEW > (
	LOOKAHEAD(2) < IDENT > < LPAREN > arglist(f1) < RPAREN > |
	(< INTEGER > | < STRING > | < CHAR > | < BOOLEAN > | < FLOAT > | < IDENT >)
	(< LBRACKET > expression(f2) < RBRACKET >)+
  )
}

void expression(RecoverySet g) throws ParseEOFException :
{
}
{
  try {
    numexpr() [( < LT > | < GT > | < LE > | < GE > | < EQ > | < NEQ >) numexpr()]
  }
  catch (ParseException e)
  {
    consumeUntil(g, e, "expression");
  }
}

void numexpr() throws ParseEOFException :
{}
{
    term() ((<PLUS> | <MINUS> ) term())*
}

void term() throws ParseEOFException :
{}
{
    xorexpr() ((<MULTIPLY> | <DIVIDE> | <REM> ) xorexpr())*
}

void xorexpr() throws ParseEOFException :
{}
{
	andexpr() ((<XOR> | <OR>) andexpr())*
}

void andexpr() throws ParseEOFException :
{}
{
	notexpr() (<AND> notexpr())*
}

void notexpr() throws ParseEOFException :
{}
{
	[(<NOT>)] unaryexpr()
}

void unaryexpr() throws ParseEOFException :
{}
{
    [(<PLUS> | <MINUS>)] factor()
}

void factor() throws ParseEOFException :
{}
{
    (
        <integer_constant> | <string_constant> | <null_constant> | <boolean_constant> | <char_constant> | <float_constant> | lvalue(null) | <LPAREN> expression(null) <RPAREN>
    )
}

void arglist(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(COMMA).union(g);
}
{
  [expression(f) (< COMMA > expression(f))*]
}

void program() throws ParseEOFException:
{
    RecoverySet g = new RecoverySet(EOF);
}
{
    try
    {
        [ classlist(g) ] <EOF>

    } catch (ParseException e)
    {
      	consumeUntil(g, e, "program");
    }
}
