/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
}

PARSER_BEGIN(Fun)
package parser;

public class Fun
{
  boolean MenosShort = false;

  public static void main(String args []) throws ParseException
  {
    String filename = "";
    Fun parser;
    boolean ms = false;
    String intro_msg = "Trabalho de Introdução a Compiladores. ";
    String modo_padrao_msg = "Fun está operando em modo padrão.";
    String modo_arquivo_msg = "Fun está operando em modo leitura de arquivo.";
    String input_msg = "Insira o valor que deseja validar (Para sair Ctrl+C)";
    String usage_msg = "Uso : -short <path/do/arquivo> \n Pode ser utilizado sem parametros para modo de input de valores";
    String file_not_found_msg = "Arquivo não foi localizado, favor verificar se está correto";
    String reading_file_msg = "Lendo o arquivo : ";
    String lexical_error_msg = " erros lexicos foram encontrados";

    System.out.println(intro_msg);

    if (args.length == 0)
    {
      System.out.println(modo_padrao_msg);
      parser = new Fun(System.in);
      parser.MenosShort = false;
      System.out.println(input_msg);
      try
      {
        parser.program();
        lexError(lexical_error_msg, parser.token_source.foundLexError());
      }
      catch (Exception ex)
      {
        System.err.println(ex);
        System.exit(0);
      }
    }
    else
    {
        // Imprimi mensagem de auxilio (Usage Message)
        if ( args.length == 1)
        {
            System.out.println(usage_msg);
            System.exit(0);
        }
        // TODO : Assume que apenas 1 arquivo será passado por vez,
        //        melhorar os argumentos para tratar multiplos arquivos.
        else if (args.length == 2)
        {
            if (args[0].toLowerCase().equals("-short"))
            {
                ms = true;
            }
            else
            {
                System.out.println(usage_msg);
                System.exit(0);
            }

            filename = args[1];
            System.out.println(reading_file_msg + filename);
            try {
                parser = new Fun(new java.io.FileInputStream(filename));
                parser.MenosShort = ms;
                parser.program();
                lexError(lexical_error_msg, parser.token_source.foundLexError());
            }
            catch (java.io.FileNotFoundException e)
            {
                System.out.println(file_not_found_msg);
                System.exit(0);
            }
        }
    }
  }

  static public String im(int x)
  {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try
    {
      s = s.substring(1,k);
    }
    catch (StringIndexOutOfBoundsException ex)
    {
        System.out.println(ex);
        System.exit(0);
    }

    return s;
  }

  static public void lexError(String msg, int errorCount)
  {
      String program_success_msg = "O programa foi corretamente analisado";

      if (errorCount != 0)
      {
        System.out.println(errorCount + msg);
      }
      else
      {
        System.out.println(program_success_msg);
      }
  }
}

PARSER_END(Fun)

TOKEN_MGR_DECLS:
{
    int countLexError = 0;

    public int foundLexError()
    {
        return countLexError;
    }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SKIP:
{
  "/*" : MULTICOMMENTMODE
}

SKIP:
{
  "//" : SINGLECOMMENTMODE
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < ASSIGN : "=" >
| < DIVIDE : "/" >
| < NOT : "!" | "not" | "NOT" >
| < AND : "&&" | "and" | "AND" >
| < OR : "||" | "or" | "OR" >
| < XOR : "^" | "xor" | "XOR" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE: "<=">
| < GE: ">=">
| < NEQ : "!=" | "><" >
| < REM : "%" >
}

TOKEN :
{
  < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
| < STRING : "string" >
| < INTEGER : "int" >
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN :
{
      < float_constant : ( ("-")? ( (["0"-"9"])+ "." (["0"-"9"])+) ) >
    | < integer_constant : ( ("-")? (["0"-"9"])+ ) >
    | < boolean_constant : "true" | "false" | "True" | "False" >
    | < char_constant : "\'" ( ["A"-"Z"] | ["a"-"z"]
                        |  ["0"-"9"] | <VALIDSIMBOLS>
                        | ("\\""n") | ("\\""t") | ("\\""r") | ("\\""f") | ("\"") )
                          "\'">
    | < string_constant : "\"" ( ["A"-"Z"] | ["a"-"z"]
                        | ["0"-"9"] | <VALIDSIMBOLS>
                        | ("\\""t") | ("\\""f") | ("\'")
                        )+ "\"" >
}

TOKEN :
{
  < CONSTANT : (< DIGIT >)+ >
| < IDENT: ( <LETTER> (<LETTER> | <DIGIT> )* )>
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER: ["A"-"Z", "a"-"z"] >
| < #VALIDSIMBOLS : ["a"-"z", "A"-"Z", "0"-"9", "(", ")",
                     "[", "]", "{", "}", ";", ",", ".", "=",
                     ">", "<", "!", "+", "-", "*", "/", "%", " ", "$", "^"] >
}

// Item 2
<MULTICOMMENTMODE> SKIP:
{
  "*/" : DEFAULT
  | <~[]>
}

<SINGLECOMMENTMODE> SKIP:
{
  <["\n","\r"]> : DEFAULT
  | <~[]>  

}

// Item 3
SPECIAL_TOKEN :
{
     <INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "\'", "(",
                         ")", "[", "]", "{", "}", ";", ",", ".", "=",
                         ">", "<", "!", "+", "-", "*", "/", "%", " ", "\t",
                         "\n", "\r", "\f"] )+ >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String invalida encontrada: " + image);
        countLexError++;
     }
|    <INVALID_CONST: ("\"" (~ ["\n", "\r", "\""])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String constante tem " + image + " seguido de \\n: ");
        countLexError++;
     }
|    <INVALID_CHAR: ("\'" (~ ["\n", "\r", "\""])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - Char constante tem " + image + " seguido de \\n");
        countLexError++;
     }
|     <INVALID_DOLLAR_SIGN_IDENT: ( "$" <IDENT> ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Isso não é PHP! =D");
        countLexError++;
     }
|    <INVALID_FLOAT: ( "." <DIGIT> | <DIGIT> ".") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não é um valor Float valido : " + image);
        countLexError++;
     }
|    <INVALID_LINE_BREAK: ("\"" ((<LETTER> | <DIGIT> )* (("\\""n") | ("\\""r"))  (<LETTER> | <DIGIT> )*) "\"") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir quebra de linha no meio de string : ");
        countLexError++;
     }
}

void program() :
{}
{
    (
          <IDENT> { System.out.println("Reconheceu IDENTIFICADOR"); }
        | <PLUS> { System.out.println("Reconheceu OPERADOR MAIS"); }
        | <MINUS> { System.out.println("Reconheceu OPERADOR MENOS"); }
        | <MULTIPLY> { System.out.println("Reconheceu OPERADOR MULTIPLICACAO"); }
        | <DIVIDE> { System.out.println("Reconheceu OPERADOR DIVISAO"); }
        | <FLOAT> { System.out.println("Reconheceu FLOAT"); }
        | <float_constant> { System.out.println("Reconheceu FLOAT VALUE"); }
        | <BOOLEAN> { System.out.println("Reconheceu BOOLEAN"); }
        | <boolean_constant> { System.out.println("Reconheceu BOOLEAN VALUE"); }
        | <CHAR> { System.out.println("Reconheceu CHAR"); }
        | <char_constant > { System.out.println("Reconheceu CHAR VALUE"); }
        | <NOT> { System.out.println("Reconheceu NOT"); }
        | <AND> { System.out.println("Reconheceu AND"); }
        | <OR> { System.out.println("Reconheceu OR"); }
        | <XOR> { System.out.println("Reconheceu XOR"); }
        | <INTEGER> { System.out.println("Reconheceu INTEGER"); }
        | <integer_constant> { System.out.println("Reconheceu NUMERO INTEIRO"); }
        | <LPAREN> { System.out.println("Reconheceu ABRE PARENTES"); }
        | <RPAREN> { System.out.println("Reconheceu FECHA PARENTES"); }
        | <ASSIGN> { System.out.println("Reconheceu OPERADOR IGUAL"); }
        | <GT> { System.out.println("Reconheceu OPERADOR MAIOR QUE"); }
        | <LT> { System.out.println("Reconheceu OPERADOR MENOR QUE"); }
        | <EQ> { System.out.println("Reconheceu OPERADOR IGUAL"); }
        | <LE> { System.out.println("Reconheceu OPERADOR MENOR IGUAL QUE"); }
        | <GE> { System.out.println("Reconheceu OPERADOR MENOR IGUAL QUE"); }
        | <NEQ> { System.out.println("Reconheceu OPERADOR DIFERENTE DE "); }
        | <REM> { System.out.println("Reconheceu OPERADOR PORCENTO"); }
        | <LBRACE> { System.out.println("Reconheceu ABRE CHAVES"); }
        | <RBRACE> { System.out.println("Reconheceu FECHA CHAVES"); }
        | <LBRACKET> { System.out.println("Reconheceu ABRE COLCHETES"); }
        | <RBRACKET> { System.out.println("Reconheceu FECHA COLCHETES"); }
        | <SEMICOLON> { System.out.println("Reconheceu PONTO E VIRGULA"); }
        | <COMMA> { System.out.println("Reconheceu VIRGULA "); }
        | <DOT> { System.out.println("Reconheceu PONTO"); }
        | <STRING> { System.out.println("Reconheceu STRING"); }
        | <string_constant> { System.out.println("Reconheceu STRING VALUE"); }
    )*
}
