/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;

import java.io.*;

public class Fun
{
  boolean MenosShort = false;
  int contParseError = 0;

  public static void main(String args []) throws ParseException
  {
    String filename = "";
    Fun parser;
    boolean ms = false;
    String intro_msg = "Trabalho de Introdução a Compiladores. ";
    String modo_padrao_msg = "Fun está operando em modo padrão.";
    String modo_arquivo_msg = "Fun está operando em modo leitura de arquivo.";
    String input_msg = "Insira o valor que deseja validar (Para sair Ctrl+C)";
    String usage_msg = "Uso : -short <path/do/arquivo> \n Pode ser utilizado sem parametros para modo de input de valores";
    String file_not_found_msg = "Arquivo não foi localizado, favor verificar se está correto";
    String reading_file_msg = "Lendo o arquivo : ";
    String lexical_error_msg = " erros lexicos foram encontrados";
    boolean debug = false;
    int i = 0;

    System.out.println(intro_msg);

    if (args.length == 0)
    {
      System.out.println(modo_padrao_msg);
      parser = new Fun(System.in);
      parser.MenosShort = false;
      System.out.println(input_msg);
      try
      {
        parser.program();
        lexError(lexical_error_msg, parser.token_source.foundLexError());
      }
      catch (Exception ex)
      {
        System.err.println(ex);
        System.exit(0);
      }
    }
    else
    {
        // Imprimi mensagem de auxilio (Usage Message)
        if ( args.length == 1)
        {
            System.out.println(usage_msg);
            System.exit(0);
        }
        // TODO : Assume que apenas 1 arquivo será passado por vez,
        //        melhorar os argumentos para tratar multiplos arquivos.
        else
        {

            for (i = 0; i < args.length - 1; ++i)
            {
                if (args[i].toLowerCase().equals("-short"))
                {
                    ms = true;
                }
                else if( args[i].toLowerCase().equals("-debug_as"))
                {
                    debug = true;
                }
                else
                {
                    System.out.println(usage_msg);
                    System.exit(0);
                }
            }
            filename = args[i];
            System.out.println(reading_file_msg + filename);
            try {
                parser = new Fun(new java.io.FileInputStream(filename));
                parser.MenosShort = ms;
                if (!debug)
                {
                    parser.disable_tracing(); // desabilita verbose do AS
                }

                // Infelizmente este foi o unico jeito de garantir que parser vai existir dentro do catch que
                // incrementa parser.contParseError.
                try
                {
                    parser.program();
                }
                catch (ParseException ex)
                {
                    System.err.println(ex.getMessage());
                    parser.contParseError = 1;
                } finally
                {
                    lexError(lexical_error_msg, parser.token_source.foundLexError());
                    System.out.println(parser.contParseError + " Syntatic Error Found");
                }
            }
            catch (java.io.FileNotFoundException e)
            {
                System.out.println(file_not_found_msg);
                System.exit(0);
            }
        }
    }
  }

  static public String im(int x)
  {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try
    {
      s = s.substring(1,k);
    }
    catch (StringIndexOutOfBoundsException ex)
    {
        System.out.println(ex);
        System.exit(0);
    }

    return s;
  }

  static public void lexError(String msg, int errorCount)
  {
      String program_success_msg = "O programa foi corretamente analisado";

      if (errorCount != 0)
      {
        System.out.println(errorCount + msg);
      }
      else
      {
        System.out.println(program_success_msg);
      }
  }
}

PARSER_END(Fun)

TOKEN_MGR_DECLS:
{
    int countLexError = 0;

    public int foundLexError()
    {
        return countLexError;
    }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SKIP:
{
  "/*" : MULTICOMMENTMODE
}

SKIP:
{
  "//" : SINGLECOMMENTMODE
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < ASSIGN : "=" >
| < DIVIDE : "/" >
| < NOT : "!" | "not" | "NOT" >
| < AND : "&&" | "and" | "AND" >
| < OR : "||" | "or" | "OR" >
| < XOR : "^" | "xor" | "XOR" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE: "<=">
| < GE: ">=">
| < NEQ : "!=" | "><" >
| < REM : "%" >
}

TOKEN :
{
  < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
| < STRING : "string" >
| < INTEGER : "int" >
| < BREAK : "break" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < SUPER : "super" >
| < IF : "if" >
| < ELSE : "else" >
| < FOR : "for" >
| < NEW : "new" >
| < FLUSH : "flush" >
| < CONSTRUCTOR : "constructor" >
| < CLASS : ( "class" ) >
| < EXTENDS : ( "extends" ) >
| < VOID : ("void") >
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN :
{
      < float_constant : ( ("-")? ( (["0"-"9"])+ "." (["0"-"9"])+) ) >
    | < integer_constant : ( ("-")? (["0"-"9"])+ ) >
    | < boolean_constant : "true" | "false" | "True" | "False" >
    | < char_constant : "\'" ( ["A"-"Z"] | ["a"-"z"]
                        |  ["0"-"9"] | <VALIDSYMBOLS>
                        | ("\\""n") | ("\\""t") | ("\\""r") | ("\\""f") | ("\"") )
                          "\'">
    | < string_constant : "\"" ( ["A"-"Z"] | ["a"-"z"]
                        | ["0"-"9"] | <VALIDSYMBOLS>
                        | ("\\""t") | ("\\""f") | ("\'")
                        )+ "\"" >
    | < null_constant : "null" >
}

TOKEN :
{
  < CONSTANT : (< DIGIT >)+ >
| < IDENT: ( <LETTER> (<LETTER> | <DIGIT> )* )>
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER: ["A"-"Z", "a"-"z"] >
| < #VALIDSYMBOLS : ["a"-"z", "A"-"Z", "0"-"9", "(", ")",
                     "[", "]", "{", "}", ";", ",", ".", "=",
                     ">", "<", "!", "+", "-", "*", "/", "%", " ", "$", "^"] >
}

// Item 2
<MULTICOMMENTMODE> SKIP:
{
  "*/" : DEFAULT
  | <~[]>
}

<SINGLECOMMENTMODE> SKIP:
{
  <["\n","\r"]> : DEFAULT
  | <~[]>  

}

// Item 3
SPECIAL_TOKEN :
{
     <INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "\'", "(",
                         ")", "[", "]", "{", "}", ";", ",", ".", "=",
                         ">", "<", "!", "+", "-", "*", "/", "%", " ", "\t",
                         "\n", "\r", "\f"] )+ >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String invalida encontrada: " + image);
        countLexError++;
     }
|    <INVALID_CONST: ("\"" (~ ["\n", "\r", "\""])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - String constante tem " + image + " seguido de \\n: ");
        countLexError++;
     }
|    <INVALID_CHAR: ("\'" (~ ["\n", "\r", "\'"])* ["\n","\r"] ) >
     {
        System.err.println("Line " + input_stream.getEndLine() + " - Char constante tem " + image + " seguido de \\n");
        countLexError++;
     }
|    <INVALID_FLOAT: ("-")? ( "." <DIGIT> | <DIGIT> ".") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não é um valor Float valido : " + image);
        countLexError++;
     }
|    <INVALID_LINE_BREAK: ("\"" ((<LETTER> | <DIGIT> )* (("\\""n") | ("\\""r"))  (<LETTER> | <DIGIT> )*) "\"") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir quebra de linha no meio de string. ");
        countLexError++;
     }
|    <INVALID_EMPTY_STRING: ("\""){2} >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir string vazia.");
        countLexError++;
     }
|    <INVALID_EMPTY_CHAR: ("\'"){2} >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Não pode existir char vazio.");
        countLexError++;
     }
|    <INVALID_SYMBOL_STRING: ("\"" (<INVALID_LEXICAL> | <LETTER> | <DIGIT> )*  "\"") >
     {
              System.err.println("Line " + input_stream.getEndLine() + " Character invalido dentro da string " + image);
              countLexError++;
     }
|    <INVALID_SYMBOL_CHAR: ("\'" <INVALID_LEXICAL> "\'") >
     {
        System.err.println("Line " + input_stream.getEndLine() + " Character invalido " + image);
        countLexError++;
     }
}

void classlist():
{
}
{
    classdecl() [ classlist() ]
}

void classdecl():
{
}
{
    <CLASS> <IDENT> [ <EXTENDS> <IDENT> ] classbody()
}

void classbody():
{
}
{
    <LBRACE>
        [classlist()]
        (LOOKAHEAD(3) vardecl() <SEMICOLON>)*
        (constructdecl())*
        (methoddecl())*
    <RBRACE>
}

void vardecl():
{}
{
    (<INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> )
    <IDENT> ( <LBRACKET> <RBRACKET> ) *
    (<COMMA> <IDENT> ( <RBRACKET> <LBRACKET>)* )*
}

void constructdecl():
{}
{
    <CONSTRUCTOR> methodbody()
}

void methoddecl():
{}
{
    ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> ) (<RBRACKET> <LBRACKET>)*
    <IDENT> methodbody()
}

void methodbody():
{}
{
    <LPAREN> paramlist() <RPAREN> statement()
}

void paramlist():
{}
{
    [
        ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> ) <IDENT> (<RBRACKET> <LBRACKET>)*
        ( <COMMA> ( <INTEGER> | <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> )
        <IDENT> (<RBRACKET> <LBRACKET>)* )*
    ]
}

void statement():
{}
{
    LOOKAHEAD(2)
    vardecl()
    | atribstat() <SEMICOLON>
    | printstat() <SEMICOLON>
    | readstat() <SEMICOLON>
    | returnstat() <SEMICOLON>
    | superstat() <SEMICOLON>
    | ifstat() <SEMICOLON>
    | forstat() <SEMICOLON>
    | <LBRACE> statlist() <RBRACE>
    | <BREAK> <SEMICOLON>
    | <SEMICOLON>
}

void atribstat():
{}
{
    lvalue() <ASSIGN> ( alocexpression() | expression() )
}

void printstat():
{}
{
    <PRINT> expression()
}

void readstat():
{}
{
    <READ> lvalue()
}

void returnstat():
{}
{
    <RETURN> [expression()]
}

void superstat():
{}
{
    <SUPER> <LPAREN> arglist() <RPAREN>
}

void ifstat():
{}
{
    <IF> <LPAREN> expression() <RPAREN> statement()
    [LOOKAHEAD(1) <ELSE> statement() ]
}

void forstat():
{}
{
    <FOR> <LPAREN> [atribstat()] <SEMICOLON>
                    [expression()] <SEMICOLON>
                    [atribstat()] <RPAREN>
                    statement()
}

void statlist():
{}
{
    statement() [statlist()]
}

void lvalue():
{}
{
    <IDENT> (
                <LBRACKET> expression() <RBRACKET> |
                <DOT> <IDENT> [<LPAREN> arglist() <RPAREN>]
            )*
}

void alocexpression():
{}
{
    <NEW> (
            LOOKAHEAD(2) <IDENT> <LPAREN> arglist() <RPAREN> |
            ( <INTEGER> |  <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT> )
            ( <LBRACKET> expression() <RBRACKET> )+
          )
}

void expression():
{}
{
    numexpr() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ> ) numexpr()]
}

void numexpr():
{}
{
    term() ((<PLUS> | <MINUS> ) term())*
}

void term():
{}
{
    xorexpr() ((<MULTIPLY> | <DIVIDE> | <REM> ) xorexpr())*
}

void xorexpr():
{}
{
	andexpr() ((<XOR> | <OR>) andexpr())*
}

void andexpr():
{}
{
	unaryexpr() (<AND> unaryexpr())*
}

void unaryexpr():
{}
{
    [(<PLUS> | <MINUS> | <NOT>)] factor()
}

void factor():
{}
{
    (
        <integer_constant> | <string_constant> | <null_constant> | <boolean_constant> | <char_constant> | <float_constant> | lvalue() | <LPAREN> expression() <RPAREN>
    )
}

void arglist():
{}
{
    [expression() (<COMMA> expression()) *]
}

void program() :
{}
{
    [ classlist() ] <EOF>
}
